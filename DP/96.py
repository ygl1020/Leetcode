#求有n个node总共能构成几种bst
def numTrees(self, n: int) -> int:
        """
        这题很多的细节需要注意.我们先把递归四部曲的定义再这个题目过一遍:1)dp数组代表当为n==i时有多少种组合和可能性 2)递归公式以n=3举例, 总共有5重可能性, root==1-->2, root==2-->1 root==3-->2
        我们可以把这三种可能性分别概述为左子树的可能性乘于右子树的可能性--> dp[0]*dp[2] +dp[1]*dp[1]+dp[2]*dp[0] 那么我们知道dp[3]的可能性是从n==1到3为root的所有的左右子树可能性乘积的和
        最后如果把i代表从1-到n个node 然后j代表每一个node为root的可能性-->dp[i] += dp[j-1]*dp[i-j]-->从1到i为root的所有左子树的可能性乘于右子树的可能性的累加
        3)初始化我们需要构建一个[0]*(n+1)的数组,因为我们要把可能性进行累加所有初始化为0,代表从0开始累加 然后node为0也是bst因此初始化为1. 4)递归顺序很明显从小到大
        
        
        这题的思路是这样的,如果n=3，那么root node的可能性为1，2，3,那么root node为1，2，3的可能性分别为当root node为1时左子树的可能性*右子树的可能性, 我们延申这个思路计算root node为2，3时的可能性
        最后把这三种可能性相加就可以得出总的可能性.那么下一个问题是当 n=i, root node=j时左右子树的可能性是什么呢？根据示例的规律我们得知左子树的规律是dp[j-1], 右子树的是dp[i-j]即当n=1, j为1,那么左右子树的
        可能性为1*1， 所以我们dp数组含义为当节点有i个时,有dp[i]总可能性. dp数组的初始化根据dp公式可得之需要把dp[0]初始化为1,因为node0也是一种bst.递推公式为dp[i]+= dp[j-1] *dp[i-j]
        
        这题和integer break的思路其实是类似的,为了求dp[4]的组合我们先求dp[3]然后dp[3]又是由dp[2]得出..
        这里的第一个for循环是：calculating the dp[i] vlaue from 1 to n+1 第二个for循环是计算由j作为root时dp[j]的组合数量可能性时多少
        根据示例我们可以得知dp[3] = dp[0]+dp[1]+dp[2] 那么递归公式就是dp[i]+= dp[j-1]*dp[i-j]-->以j为root node时左右两边子树的可能性
        在第一个for循环中我们每次都会把dp[i]计算出来，然后计算出来的dp[i]会被下一个回合的i+1的过程中被直接利用
        """
        dp = [0]*(n+1) # 我们会把结果进行累加所以需要初始化为0
        dp[0]=1
        for i in range(1,n+1): # 代表从1开始到n的所有的可能性
            for j in range(1,i+1): #代表从1开始到i的所有的root组合
                dp[i] += dp[j-1] * dp[i-j]
        print(dp)
        return dp[n]